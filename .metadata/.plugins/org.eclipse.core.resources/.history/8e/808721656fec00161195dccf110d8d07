package io.d0048.gather;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Properties;

public class InfoSenser {
	PcInfo pcinfo = new PcInfo();
	static String ipRegex = "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}";
	static String macRegex = "[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]";
	
	public PcInfo sense(){
		this.pcinfo.ips = InfoSenser.getIpAddresses();
		this.pcinfo.os = InfoSenser.getOs();
		this.pcinfo.hostNames = InfoSenser.getHostNames();
		try {
			this.pcinfo.accurateIps = InfoSenser.getAccurateIpAddresses();
		} catch (Exception e) {
			e.printStackTrace();
		}
		this.pcinfo.user = InfoSenser.getCurrentUser();
		this.pcinfo.macAddresses = InfoSenser.getMACAddress();
		this.pcinfo.props = InfoSenser.getProperties();
		this.pcinfo.lastUpDate = InfoSenser.getDate();
		
		System.out.print("ip："+pcinfo.ips.toString()+"\n");
		System.out.print("操作系统："+pcinfo.os.toString()+"\n");
		System.out.print("获得的计算机名："+pcinfo.hostNames.toString()+"\n");
		System.out.print("获得的准确IP:"+this.pcinfo.accurateIps+"\n");
		System.out.print("获得的用户名："+this.pcinfo.user+"\n");
		System.out.print("获得的MAC地址："+this.pcinfo.macAddresses.toString()+"\n");
		/*System.out.print("其他杂项：\n");
		for(Object s : this.pcinfo.props.keySet()){
		System.out.print(s.toString()+": \""+this.pcinfo.props.getProperty((String)s)+"\"\n");
		}*/
		  System.out.println("用户名:    " + userName);
	        System.out.println("计算机名:    " + computerName);
	        System.out.println("计算机域名:    " + userDomain);
	        System.out.println("本地ip地址:    " + ip);
	        System.out.println("本地主机名:    " + addr.getHostName());
	        System.out.println("JVM可以使用的总内存:    " + r.totalMemory());
	        System.out.println("JVM可以使用的剩余内存:    " + r.freeMemory());
	        System.out.println("JVM可以使用的处理器个数:    " + r.availableProcessors());
	        System.out.println("Java的运行环境版本：    " + props.getProperty("java.version"));
	        System.out.println("Java的运行环境供应商：    " + props.getProperty("java.vendor"));
	        System.out.println("Java供应商的URL：    " + props.getProperty("java.vendor.url"));
	        System.out.println("Java的安装路径：    " + props.getProperty("java.home"));
	        System.out.println("Java的虚拟机规范版本：    " + props.getProperty("java.vm.specification.version"));
	        System.out.println("Java的虚拟机规范供应商：    " + props.getProperty("java.vm.specification.vendor"));
	        System.out.println("Java的虚拟机规范名称：    " + props.getProperty("java.vm.specification.name"));
	        System.out.println("Java的虚拟机实现版本：    " + props.getProperty("java.vm.version"));
	        System.out.println("Java的虚拟机实现供应商：    " + props.getProperty("java.vm.vendor"));
	        System.out.println("Java的虚拟机实现名称：    " + props.getProperty("java.vm.name"));
	        System.out.println("Java运行时环境规范版本：    " + props.getProperty("java.specification.version"));
	        System.out.println("Java运行时环境规范供应商：    " + props.getProperty("java.specification.vender"));
	        System.out.println("Java运行时环境规范名称：    " + props.getProperty("java.specification.name"));
	        System.out.println("Java的类格式版本号：    " + props.getProperty("java.class.version"));
	        System.out.println("Java的类路径：    " + props.getProperty("java.class.path"));
	        System.out.println("加载库时搜索的路径列表：    " + props.getProperty("java.library.path"));
	        System.out.println("默认的临时文件路径：    " + props.getProperty("java.io.tmpdir"));
	        System.out.println("一个或多个扩展目录的路径：    " + props.getProperty("java.ext.dirs"));
	        System.out.println("操作系统的名称：    " + props.getProperty("os.name"));
	        System.out.println("操作系统的构架：    " + props.getProperty("os.arch"));
	        System.out.println("操作系统的版本：    " + props.getProperty("os.version"));
	        System.out.println("文件分隔符：    " + props.getProperty("file.separator"));
	        System.out.println("路径分隔符：    " + props.getProperty("path.separator"));
	        System.out.println("行分隔符：    " + props.getProperty("line.separator"));
	        System.out.println("用户的账户名称：    " + props.getProperty("user.name"));
	        System.out.println("用户的主目录：    " + props.getProperty("user.home"));
	        System.out.println("用户的当前工作目录：    " + props.getProperty("user.dir"));
	    
		System.out.print("上次更新时间："+this.pcinfo.lastUpDate+"\n");
		
		return this.pcinfo;
	}
	
	public PcInfo getPcinfo() {
		return pcinfo;
	}

	public void setPcinfo(PcInfo pcinfo) {
		this.pcinfo = pcinfo;
	}

	public static String getOs(){
		 String os = System.getProperty("os.name");
		 return os;
	}
	
	public static HashSet<String> getHostNames(){
		HashSet <String> hostNames = new HashSet<String>();
		try{
			//this.pcinfo.ips.add(InetAddress.getLocalHost());
			for( InetAddress ip : InetAddress.getAllByName(InetAddress.getLocalHost().getHostName()) ){
				hostNames.add(ip.getHostName().trim());
			}
		}
		catch(UnknownHostException e){
			e.printStackTrace();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return hostNames;
	}
	
	public static HashSet<InetAddress> getIpAddresses(){
			HashSet <InetAddress>ips = new HashSet<InetAddress>();
		try{
			for( InetAddress ip : InetAddress.getAllByName(InetAddress.getLocalHost().getHostName()) ){
				ips.add(ip);
			}
		}
		catch(UnknownHostException e){
			e.printStackTrace();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		return ips;
	}
	
	public static ArrayList <String> getAccurateIpAddresses() throws Exception{
		//String ipRegex = "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}";//IP过滤表达式
		String os = System.getProperty("os.name");
		//linux使用
		if(os != null && os.startsWith("Linux")){
			boolean filterFirst = false;
			ArrayList <String> finals = new ArrayList<String>();;
			String[] command = {"LC_ALL=C ifconfig  | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'"};
			String rawIps=Executer.linuxExec(command);
			for(String s : rawIps.split("\n")){
				if(filterFirst) finals.add(s.trim());
				filterFirst = true;
			}
			return finals;
		}
		//windows使用
		if(os != null && os.startsWith("Windows")){
			ArrayList <String>finals = new ArrayList<String>();
			//Pattern pattern = Pattern.compile(this.ipRegex);
			String[] command = {"ipconfig /all"};
			String result = Executer.windowsExec(command);
			for(String p : result.split(" ")){
				//pieces.add(p);
				if(p.matches(ipRegex)){
					finals.add(p.trim());
				}
			}
			return finals;
			//return pattern.split(Executer.windowsExec(command));
		}
		else{
			throw new Exception("此系统不兼容");
		}
	}
	
	public static String getCurrentUser(){
		String osUser=System.getProperty("user.name");
		return osUser;
	}
	
	public static HashSet<String> getMACAddress(){
		HashSet<String> macAddresses = new HashSet<String>();
        String address = "";
        String os = System.getProperty("os.name");
        //windows使用
        if (os != null && os.startsWith("Windows")) {
            try {
                String command = "cmd.exe /c ipconfig /all";
                Process p = Runtime.getRuntime().exec(command);
                BufferedReader br =new BufferedReader(new InputStreamReader(p.getInputStream()));
                String line;
                while ((line = br.readLine()) != null) {
                    if (line.indexOf("Physical Address") > 0) {
                        int index = line.indexOf(":");
                        index += 2;
                        address = line.substring(index);
                        macAddresses.add(address);
                    }
                }
                br.close();
                return macAddresses;
            }
            catch (IOException e) {
            	e.printStackTrace();
            }
        }
        //linux使用
        if (os != null && os.startsWith("Linux")) {
        	String[] command = {"ip link show"};
        	//String result = Executer.linuxExec(command);
        	
        	for(String s : Executer.linuxExec(command).split(" ")){
        		//System.out.print(s+"\n");
        		if(s.trim().toUpperCase().matches(macRegex)){
        			macAddresses.add(s.trim());
        		}
        	}
        //findAll(Executer.linuxExec(command), macRegex);
        }
        return macAddresses;
    }
	/*
	public static HashSet<String> findAll(String source, String targetRegex){
		HashSet<String> targets = new HashSet<String>();
		Pattern p = Pattern.compile(targetRegex);
		Matcher m=p.matcher("source");
		while(m.find()) { 
			String found = m.group();
			targets.add(found);
			System.out.println("I found:"+found); 
		}
		return targets;
	}
*/
	public static Properties getProperties(){
		Properties props=System.getProperties();
		return props;
	}
	
	public static Date getDate(){
		return new Date();
	}
}
